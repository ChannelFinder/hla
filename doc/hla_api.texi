\input texinfo @c -*-texinfo-*-
@setfilename hla.info
@settitle High Level Applications
@finalout
@c %**end of header

@dircategory Scientific software
@direntry
* hla: (hla).               High Level Applications
@end direntry

@tex
% Mathematical macros taken from the GNU Calc Manual
% ==================================================
%
% Some special kludges to make TeX formatting prettier.
% Because makeinfo.c exists, we can't just define new commands.
% So instead, we take over little-used existing commands.
%
% Redefine @cite{text} to act like $text$ in regular TeX.
% Info will typeset this same as @samp{text}.
\gdef\goodtex{\tex \let\rm\goodrm \let\t\ttfont \turnoffactive}
\gdef\goodrm{\fam0\tenrm}
\gdef\math{\goodtex$\mathxxx}
\gdef\mathxxx#1{#1$\endgroup}
\global\let\oldxrefX=\xrefX
\gdef\xrefX[#1]{\begingroup\let\math=\dfn\oldxrefX[#1]\endgroup}
%
% Redefine @i{text} to be equivalent to @cite{text}, i.e., to use math mode.
% This looks the same in TeX but omits the surrounding ` ' in Info.
%\global\let\i=\cite
%\global\let\math=\cite
%
% Redefine @c{tex-stuff} \n @whatever{info-stuff}.
\gdef\c{\futurelet\next\mycxxx}
\gdef\mycxxx{%
  \ifx\next\bgroup \goodtex\let\next\mycxxy
  \else\ifx\next\mindex \let\next\relax
  \else\ifx\next\kindex \let\next\relax
  \else\ifx\next\starindex \let\next\relax \else \let\next\comment
  \fi\fi\fi\fi \next
}
\gdef\mycxxy#1#2{#1\endgroup\mycxxz}
\gdef\mycxxz#1{}
%
% Define \Hat to take over from \hat as an accent
\gdef\Hat{\mathaccent "705E}
%
%\gdef\beforedisplay{\vskip-10pt}
%\gdef\afterdisplay{\vskip-5pt}
\gdef\beforedisplay{}
\gdef\afterdisplay{}
{\globaldefs = 1
\abovedisplayskip=7pt plus 2pt minus 1pt
\belowdisplayskip=7pt plus 2pt minus 1pt
\abovedisplayshortskip=7pt plus 2pt minus 1pt
\belowdisplayshortskip=7pt plus 2pt minus 1pt}
%\abovedisplayskip=12pt plus 3pt minus 3pt
%\belowdisplayskip=12pt plus 3pt minus 3pt
%\abovedisplayshortskip=7pt plus 1pt minus 1pt
%\belowdisplayshortskip=7pt plus 1pt minus 1pt
%\gdef\beforedisplayh{\vskip-25pt}
%\gdef\afterdisplayh{\vskip-10pt}
%
\gdef\arcsec{\hbox{\rm arcsec}}
\gdef\arccsc{\hbox{\rm arccsc}}
\gdef\arccot{\hbox{\rm arccot}}
\gdef\sech{\hbox{\rm sech}}
\gdef\csch{\hbox{\rm csch}}
\gdef\coth{\hbox{\rm coth}}
\gdef\arcsinh{\hbox{\rm arcsinh}}
\gdef\arccosh{\hbox{\rm arccosh}}
\gdef\arctanh{\hbox{\rm arctanh}}
\gdef\arcsech{\hbox{\rm arcsech}}
\gdef\arccsch{\hbox{\rm arccsch}}
\gdef\arccoth{\hbox{\rm arccoth}}
%
\gdef\Re{\hbox{\rm Re}}
\gdef\Im{\hbox{\rm Im}}
\gdef\Sin{\hbox{\rm Sin}}
\gdef\Cos{\hbox{\rm Cos}}
\gdef\Log{\hbox{\rm Log}}
%
\gdef\erf{\hbox{\rm erf}}
\gdef\erfc{\hbox{\rm erfc}}
\gdef\sinc{\hbox{\rm sinc}}
\gdef\sgn{\hbox{\rm sgn}}
\gdef\sign{\hbox{\rm sign}}
\gdef\det{\hbox{\rm det}}
\gdef\Var{\hbox{\rm Var}}
\gdef\arg{\hbox{\rm arg}} % avoid temporary clobbering of arg in texinfo-4.8
@end tex

@copying

This manual is for part of the tools designed for accelerator
commissioning and physics. It is original for NSLS-II (National
Synchrotron Light Source II) project, which is under construction at
Brookhaven National Laboratory.

Copyright @copyright{} 2010 The NSLS-II Project.

@c Permission is granted to copy, distribute and/or modify this document
@c under the terms of the GNU Free Documentation License, Version 1.3 or
@c any later version published by the Free Software Foundation; with the
@c Invariant Sections being "GNU General Public License" and "Free Software
@c Needs Free Documentation", the Front-Cover text being "A GNU Manual",
@c and with the Back-Cover Text being (a) (see below).  A copy of the
@c license is included in the section entitled "GNU Free Documentation
@c License".

@c (a) The Back-Cover Text is: "You have the freedom to copy and modify this
@c GNU Manual."
@end copying

@titlepage
@title High Level Applications (API)
@subtitle Tools for Accelerator Commissioning and Physics

@vskip 5ex
Schedule:
@itemize @bullet
@item 12/01/2011--02/29/2012, LINAC front end
@item 03/30/2012--07/28/2012, LINAC
@item 05/29/2012--06/28/2012, LBTL in LINAC
@item 07/28/2012--08/27/2012, LBTL
@item 08/27/2012--12/25/2012, Booster
@item 12/15/2012--01/14/2013, BSTL in Booster tunnel
@item 01/14/2013--01/24/2013, BSTL
@item 01/24/2013--09/21/2013, Storage Ring Commissioning Part 1
@item 09/21/2013--11/20/2013, ID installation
@item 11/20/2013--02/18/2014, Storage Ring Commissioning Part 2
@end itemize

@vskip 5ex
@include hlaversion.texi
@comment @author Jinhyuk Choi
@author Guobao Shen (@email{shengb@@bnl.gov})
@author Lingyun Yang (@email{lyyang@@bnl.gov})
@comment @email{tuomo.keskitalo@iki.fi}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents


@node Introduction
@chapter Introduction

This manual is a brief list of high level applications (HLA) application
programming interface (API). It serves as an quick view of APIs and
their functions. 

For general design overview and the applications or scripts used in beam
commissioning, please refer HLA user guide.

For detailed specifications of each input parameters, please refer the
API reference book coming with HLA source code.


@node Client APIs (CAPI)
@chapter Client APIs (CAPI)

This section describes the high level API which is used in the HLAs,
scripts and the interactive environment.

The client APIs are a set of high level functions with physics
meanings. It hides the low level function calls from its users, who are
mainly accelerator physicists, operators and high level GUI application
developers. It is not required for a user of CAPI to have any
knowledge of EPICS system such as channel access and/or pv name. A
user can get all desired data with hardware name (magnets for
example), location, group, .... 

The internals of CAPI needs a configure file which links abstract
hardware name, their location or any abstract symbol representing them
to real EPICS channels.

Roughly speaking, CAPI is a subset of Matlab Middle Layer, while High
Level Applications/Scripts (HLA) are not.

The API name follows the convention as described (@pxref{Acronym and API
Prefix}). Addtion to that, some commonly used abbreviation is treated as
one word, only the first letter is in upper case. e.g. @strong{Bpm}
(beam position monitor), @strong{Rm} (response matrix), @strong{Sp}
(setpoint), @strong{Rb} (readback), @strong{Rf} (radio frequency),
@strong{Fofb} (fast orbit feedback), @strong{Sofb} (slow orbit
feedback).

The error processing of these APIs are in defined global constant or in
forms of exception, instead of meaningless integer numbers.
integer. Some error codes are proposed as below:
@itemize @bullet
@item @math{0}: successful
@item @math{1}: fault
@item @math{2}: object, group for example, is not empty
@item @math{3}: object, element/group name for example, does not exist
@item @math{4}: object, element/group for example, already exist
@end itemize

The GUI part will not be included here. But Lingyun suggested that
@code{PyQt} is a good candidate for Python. It is easier to use and full of features.

Here is a demo of how a short script looks like:

@example
#!/usr/bin/env python
import capi as sr
import numpy as np
import time
# returns all channels belongs to group "CELL30" and "BPMx"
bpms1 = sr.getMembers(group="CELL30", group="BPMx")
# get orbit at cell 30
orbit1 = sr.getOrbit(bpms1)
orbit_sq2 = np.sum(orbit1*orbit1)
time.sleep(2)
# exactly same as before, get all BPMs in cell 30
bpms2 = sr.getMembers(group="P*C30*", group="BPMx")
orbit2 = sr.getOrbit(bpms2)
orbit_sq2 = np.sum(orbit2*orbit2)
orbit_diff = np.zeros(len(orbit2), 'd')
for i,bpm in enumerate(bpms2):
    orbit_diff[i] = orbit2[i] - orbit1[bpms1.index(bpm)]
@end example

These APIs are available in interactive environment in a slight different
form due to different language binding, e.g. getOrbit in interactive
environment may looks like ::

@example
#!/usr/bin/env python
import matplotlib.pylab as plt
import capi as sr
# get orbit at PH1G2C30A, PM1G4C30A (index starts at 0)
orbit = sr.getOrbit(sequence=[[0,0], [0,2]])
plt.plot(bpmlocation, orbit[:,0], '-o', label=''H'')
plt.plot(bpmlocation, orbit[:,1], '-x', label=''V'')
@end example

While in a C/C++ bindings (typically in a matured HLA, who evolved from a
script to a standalone stable application) look like the following

@example
#include ``capi.h''
int main(int argc, char* argv[])
@{
    getOrbit(x, y, bpmlist);
    getOrbit(x, y, "PM[1-2]*C20*");
@}
@end example

It is not clear yet, whether or when do we need the C/C++ bindings. In
the first days of commissioning, Python scripts and applications are
able to fulfil all tasks.

@node Data Management
@section Data Management

There are many global configurations and data need to be organized, and
a centralized way is preferred. Update one should be visiable to other
applications if those applications are in same framework as HLA.

Operators or accelerator physicists can have their own directory for
storing data, and it is separated from machine setup or different modes.
They can also have their own scripts, but we suggest them use a code
repository as we are using for better version tracking, compatability
and backup.

The data required for machine operation needs to be in centralized
space, while user data/plots can be on a file system in their own
directory. The data HLA relies on and controls are:

@enumerate
@item Operation mode. 

One mode is like one brand new storage ring. The mode returns only
properties like mode name, description, and so on. Associated machine
configuration, magnet power supply setting for example is stored
separatedly, and can be retrieved using the mode name. The data
structure is as below:

    @enumerate
    @item @emph{mode name},

    The mode name is treated as a string, such as "simulator", "operation", "AccPhys1", "low alpha", "low beta"

    @item @emph{description},

    Any description is added here when this mode is created, and/or
    modified.

    Date format: Simple string, approximately with the size of one paragraph.

    @item @emph{create date},

    This identifies the first time that this mode is created.

    Date format: ISO 8601 format, ``YYYY-MM-DDTHH:MM:SS.mmmmmm'', e.g. '2002-12-25T00:00:00' or '2002-12-25 00:00:00', need discussion on @strong{UTC} or @strong{local} time with daylight saving ?

    @item @emph{modified date},

    This identifies the last date that this mode is modified.

    Date format: ISO 8601

    @item @emph{creator}. 

    This identifies who creates this model.

    @end enumerate 

    Related APIs: @code{getCurrentMode}, @code{getModeInfo}, @code{getAllModes}.

    A version tracked storage is preferred (e.g. In database, or in file system with different directory).

@item Lattice organization:

    The bare lattice can be saved and restored with this information.

    @enumerate
    @item @emph{element full name} 

    The element physics name, which follows the NSLS-II nomenclature
    standard, and each name is unique.

    @item @emph{element type}

    This information is used to define a 

    @itemize @bullet
    @item MARKER, a marker  
    @item DRIFT, drift space
    @item DIPOLE, main dipole
    @item QUADRUPOLE, quadrupole
    @item SEXTUPOLE, sextupole
    @item CORRECTOR, corrector.
    @item BPM, beam position monitor
    @item RF, radio frequency
    @end itemize

    @item @emph{element s-location}

    The element position along @emph{s} direction. The value depends
    on the coordinate definition. Should it be unique?

    Unit: [meter]

    @item @emph{element length}

    The element length.

    Unit: [meter]

    @item @emph{K1 value}

    The default K1 value. Typically, this is for bare lattice.

    Unit: [1/meter^2]

    @item @emph{K2 value}

    The default K2 value. Typically, this is for bare lattice.

    Unit: [1/meter^3]


    @item @emph{angle}

    The default bending angle. Typically, this is for main dipole. The
    bending angle should be zero for other type magnet.

    Unit: [rad]

    @item @emph{...}

    Other information to be added here.

    Unit: [a.u.]

    @end enumerate

    Related APIs: @code{getBareLattice} @code{saveBareLattice}

@item Machine configuration:

    @enumerate
    @item @emph{element groups}

    multiple string, can be added by users. For export to elegant,
    need a group name for its type like "Quadrupole", "Sextupole",
    "RF"

    Default groups for each subsystems:
    @itemize @bullet
    @item Magnet
    @itemize @bullet
    @item Groups from its type: @emph{Dipole}, @emph{Quadrupole}, @emph{Sextupole}, @emph{Corrector}, (also @emph{HCorrector} or/and @emph{VCorrector} if it has x/y direction), @emph{Bpm}, @emph{SkewQuadrupole}
    @item Groups from its symmetry: @emph{Cell01A}, @emph{Cell01}, @emph{Cell01B}, ..., @emph{Girder2}, @emph{Girder4}, ...
    @end itemize
    @item Power Supply
    @item Diagnostic
    @itemize @bullet
    @item BPMx
    @item BPMy
    @item ...
    @end itemize
    @item Vaccum
    @item RF (Radio Frequency)
    @item PPS (Personal Protection System)
    @item EPS (Equipment Protection System)
    @item ...
    @end itemize
      
    @item @emph{setting/reading channels}

    readback/setpoint, may have more channels associated with one magnet/element
      
    @item @emph{setting/reading channel limits}

    lower and upper bound
      
    @item @emph{channel set/read unit}, unit for each channel
      
    @item @emph{channel label}, when plotting, default label
      
    @item @emph{online(enabled)/offline(disabled) status}
      
    @item @emph{cell number, girder number}
      
    @item @emph{bpm sequence number}

    @item @emph{alignment error}
    @itemize @bullet
    @item dx. alignment error at @emph{x} direction
    @item dy. alignment error at @emph{y} direction
    @item ds. alignment error at @emph{s} direction
    @c @item pitch. alignment error at @emph{???} direction
    @c @item yaw. alignment error at @emph{???} direction
    @item roll. alignment error at @emph{???} direction
    @end itemize

    @end enumerate

The configure file may look like the following ::

@example
  <?xml version="1.0" encoding="UTF-8">
  <lattice name="NSLS-II" mode=''nominal''>
      <element>
          <name link="Ha">CH1YSP01</name>
          <cell>1</cell>
          <girder>2</girder>
          <group>Corrector</group>
          <group>VCorrector</group>
          <group>BeamBasedAlignment</group>
          <setpoint>0.0</setpoint>
          <pv name="SR:C01-MG:G03A.SP">HKICK</pv>
          <location>3.5</location>
      </element>
      <element> ... </element>
   </lattice>
   <lattice name=''booster'' mode=''default>
   </lattice>
@end example

This is a horizontal orbit corrector @code{CH1YSP01}, it belongs to @code{section 1},
@code{girder 2}, together with other elements, it is in two groups called
@code{Corrector} and @code{HCorrector}, it is also linked to a power supply @code{Ha},
to which other horizontal corrector may belongs. The group name
@code{BeamBasedAlignment} also implies that this corrector will be used for
beam based alignment.

More information can be added to this configure file. 

     @itemize
     @item Orbit correction ?
     @item Tune correction ?
     @item Chromaticity correction ?
     @end itemize

This file is needed by HLAs, and easily ported to other storage
rings. We can provide a local copy of this file or access it from
network (API or network file system).

Related APIs: @code{getGroups}, @code{getLocation},
@code{getAllGroups}, @code{getNeighbors}, @code{getDevice},
@code{getAlignment}, @code{getChannel}, @code{getStatus}

@item Golden orbit

Include phase advance, beta function, dispersion and 
chromaticity. All are for both horizontal and vertical planes.
      @enumerate 
      @item @emph{golden orbit}, BPM name, orbit value, unit and timestamp
      @item @emph{phase/phase advance}, BPM name, phase value, and timestamp
      @item @emph{beta function}, BPM name, beta value, and timestamp
      @item @emph{dispersion}, BPM name, dispersion, andtimestamp
      @item @emph{chromaticity}, BPM name, chromaticity, and timestamp
      @end enumerate
Related APIs: @code{getGoldenOrbit}, @code{setGoldenOrbit}, @code{saveGoldenOrbit}, @code{loadGoldenOrbit}.

Better to have these data versioned (keep track of data change, either
in the database way or in file system)
@item Orbit response matrix:

Include tune, chromaticity, RF phase and voltage. All are for both horizontal and vertical planes.
      @enumerate 
      @item @emph{orbit response matrix}, 2-d (matrix) data, unit and timestamp
      @item @emph{correctors}, a list of element names
      @item @emph{bpms}, a list of element names
      @item @emph{tunes}, value
      @item @emph{chromaticity},
      @item @emph{RF voltage}, 
      @item @emph{RF phase}, 
      @item @emph{corrector name/strength pair}
      @item @emph{closed orbit shift}, for each corrector setting, we have one set of closed orbit
      @end enumerate
Related APIs: @code{getOrbitRm}, @code{saveOrbitRm}

@item Tune correction matrix:

Include quadrupole setting. All are for both horizontal and vertical planes.
      @enumerate
      @item @emph{tune RM matrix}, 2-d (matrix) data, unit and timestamp
      @item @emph{quadrupole used}
      @item @emph{quadrupole values}
      @item @emph{tune values}
      @end enumerate
Related APIs: @code{getTuneRm}, @code{saveTuneRm}

@item Chromaticity correction matrix:
      @enumerate
      @item @emph{chromaticity RM matrix}, 2-d (matrix) data, unit and timestamp
      @item @emph{sextupole used}
      @item @emph{sextupole values}
      @item @emph{tune values}
      @item @emph{fitted polynomial coeffients}, 5 values ?
      @item @emph{RF voltage}
      @end enumerate
Related APIs: @code{getChromRm}, @code{saveChromRm}

@item Unit conversion

These data are associated with each magnet.
      @enumerate
      @item @emph{unit convertion table}, a table convert engineer(current, voltage) number to physics (mm, rad) number
      @item Sextupole/Quadrupole K-value vs. current
      @item Corrector current vs. angle/orbit shift
      @end enumerate

Related APIs: @code{TBD}

@item Step size for magnet ramping/scan, (already in lattice ? or define independently)
    @enumerate
    @item @emph{step size}, a sigle number when user want to step a channel, to see small effects. e.g. small kick of beam to see the orbit change. 
    @end enumerate
Related APIs: @code{getStepsize}, @code{stepUp}, @code{stepDown}
@end enumerate


@node Data Management API
@section Data Management API

@table @code

@deftypefun {mode =} getCurrentMode () 
Get current operation mode with @code{getCurrentMode}.

Data structure:
@enumerate
@item params: None
@item return: Current machine operation mode(@pxref{Data Management}: Operation mode)
@end enumerate

@deftypefunx {status =} saveMode (@var{mode}, @var{destination="mode_name.txt"} ) 
Save operation mode with @code{saveMode}.

Data structure:
@enumerate
@item params: mode; mode info to be saved
@item params: destination; where to save
@item return: status
@end enumerate

@deftypefunx {[modes] =} getAllModes()
Get all operation modes with @code{getAllModes()}. 

Data structure:
@enumerate
@item params: None
@item return: An array of operation mode. Each mode as (@pxref{Data Management}: Operation mode)
@end enumerate

The operation mode is used to group different response matrix, tunes,
beta and ramping for different storage ring settings. One mode can be
norminal operation mode, the others can be accelerator physics mode,
single bunch mode, different working point(tunes), low alpha mode,
low beta mode, high beta mode, ... 

@end deftypefun

@deftypefun {status =} addGroup ( @var{group} )
Add and create a new group with given group name with @code{addGroup()}. 

Data structure:
@enumerate
@item params: group - string; new group name 
@item return: status
@end enumerate

@deftypefunx {status =} removeGroup ( @var{group} )
Delete an existing group with given group name with @code{removeGroup()}. 

Data structure:
@enumerate
@item params: group - string; group name to be deleted
@item return: status
@end enumerate

@deftypefunx {status =} addGroupMember ( @var{group}, @var{members} )
Add members to an existing group with @code{addGroupMembers()}. 
If a member exists in this group, update it.

Data structure:
@enumerate
@item params: group - string; group name to add members to.
@item params: members - string array; member list to be added
Definition of members @strong{TBD}. Could be channel name, or magnet
physics name.
@item return: status
@end enumerate

@deftypefunx {status =} removeGroupMember ( @var{group}, @var{members} )
Remove member(s) from specified group @code{removeGroupMember()}. 

Data structure:
@enumerate
@item params: group - string; group name to be deleted
@item params: members - string array; member list to be deleted
@item return: status
@end enumerate

They operate on group/member management. These @var{members} support
wildcards. @code{removeGroup} should clean up the relations of members
to this group (may call @var{removeGroupMember}) or @strong{remove a
nonempty group is forbiden}, like @code{rmdir} in Linux.

All operation modes share same group settings. We can use a new group
name for various mode. e.g. If some correctors only works in ``physics''
mode, we can have a group name for them.

@strong{WARNING}: for some group, it would be nice to be readonly, too
dangerous to change in script.
@end deftypefun

@deftypefun {[groups] =} getGroups ( @var{element} )
Get group(s) that given element name belongs to with @code{getGroups()}. 

Data structure:
@enumerate
@item params: element - string; Element name.
@item return: group(s) - string array. Empty if element does not
either belong to any group nor exist.
@end enumerate

@c @deftypefunx {info=} getGroupInfo ( @var{group} )

@deftypefunx {[members] =} getMembers ( @var{group} )
Get members(s) that belongs to certain group with @code{getMembers()}. 

Data structure:
@enumerate
@item params: group - string; Group name.
@item return: member(s) - string array. Empty if group does not
either have any member nor exist.
@end enumerate

@deftypefunx {[groups] =} getAllGroups ( )
Get all group name(s) with @code{getAllGroups()}. 

@strong{To be discussed}. What is this for? How this should be processed?

Data structure:
@enumerate
@item params: None.
@item return: group(s) - string array. Empty if there is no group defined.
@end enumerate

@code{getGroups} returns group name list to which a specific element
belongs.  The element name should be uniqe in lattice. @code{getMembers}
returns all elements in a group or groups. The order of @var{members}
does matter, must be in increasing order of
@math{s}. @code{getAllGroups} returns all groups available in the
system. 

@c @code{getGroupInfo} returns the information of this single group (no wildcard/regular expression matching).
@end deftypefun

@deftypefun {[s] =} getLocation ( @var{group} )
Get @math{s} location of all element belongs to certain @var{group}, the order matters.

Data structure:
@enumerate
@item params: group - string; Group name.
@item return: s - numeric (double) array. Empty if group does not
either have any member nor exist.
@item unit: [meter].
@end enumerate

@end deftypefun

@deftypefun {[[elems], [s]] =} getNeighbors ( @var{element}, @var{group}, @var{n} )

Get a list of @math{n} elements belongs to @var{group}. The list is
sorted along @math{s} (the beam direction).

@code{getNearbyBpm} are built upon this routine, and it returns nearby
BPMs for magnets

Data structure:
@enumerate
@item params: element - string; element physics name.
@item params: group - string; group name.
@item params: n - numeric (integer); number of elements nearby. Total
elements will be @math{2*n + 1}
@item return: a 2-d array. [elems] contains all element physics name,
and [s] contains all element @math{s} location.
@end enumerate

@end deftypefun

@deftypefun {stepsize =} getStepsize ( @var{element} )
Get stepsize for scanning an element. This information is described (@pxref{Data
Management}: Step size).

Data structure:
@enumerate
@item params: element - string; element physics name.
@item return: stepsize - numeric (double). 0 if an element does not
have this property.
@end enumerate

@end deftypefun

@deftypefun {[phase] =} getPhase ( @var{mode}, @var{group}, @var{plane} )
Get phase advance at each element belonging to certain group.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: group - string; Group name.
@item params: plane - numeric; 0 - horizontal plane; 1 - vertical plane.
@item return: phase - numeric (double) array. Empty if group does not
either have any member nor exist, or mode does not exist.
Simulation value if the mode is "simulator", otherwise, measuredvalue.
@item unit: [rad].
@end enumerate

@deftypefunx {[beta] =} getBeta ( @var{mode}, @var{group}, @var{plane} )

Get beta at each element belonging to certain group.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: group - string; Group name.
@item params: plane - numeric; 0 - horizontal plane; 1 - vertical plane.
@item return: beta - numeric (double) array. Empty if group does not
either have any member nor exist, or mode does not exist.
Simulation value if the mode is "simulator", otherwise, measuredvalue.
@item unit: [meter].
@end enumerate

@deftypefunx {[eta] =} getDispersion ( @var{mode}, @var{group}, @var{plane} )

Get dispersion at each element belonging to certain group.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: group - string; Group name.
@item params: plane - numeric; 0 - horizontal plane; 1 - vertical plane.
@item return: eta - numeric (double) array. Empty if group does not
either have any member nor exist, or mode does not exist.
Simulation value if the mode is "simulator", otherwise, measuredvalue.
@item unit: [TBD].
@end enumerate

@deftypefunx {[@var{chromx}, @var{chromy}] =} getChromaticity ( @var{mode} )

Get chromaticity at certain mode.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: [hori, vert] - numeric (double) array. Empty if mode does not exist.
Simulation value if the mode is "simulator", otherwise, measuredvalue.
@item unit: [TBD].
@end enumerate

@deftypefunx {(@var{nux}, @var{nuy}) =} getTune ( @var{mode} )
@deftypefunx {(@var{nux}, @var{nuy}) =} getFftTune ( @var{mode} )
Get tune at certain mode.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: [nux, nuy] - numeric (double) array. Empty if mode does not exist.
Simulation value if the mode is "simulator", otherwise, measured value.
@item unit: [TBD].
@end enumerate

@deftypefunx {(@var{nux}, @var{nuy}) =} getTune ( )

Get measured tune in real time.

Data structure:
@enumerate
@item params: None.
@item return: [nux, nuy] - numeric (double) array. Empty if failed.
@item unit: [TBD].
@end enumerate

All @code{get*} functions are just readout, i.e. a stored value, not
real time measurement, for example @code{getChrom}, which
returns the horizontal and vertical chromaticity. The chromaticity
value should be saved together with the @var{mode} of current lattice:
"operation", "AP mode 1", "AP mode 2". They need to access the DB/file
to read the norminal values (same for phase, beta, dispersion, tune).
One excepation is @code{getTune( )}, which is a readout of online tune
measurement. 

@strong{To be discussed}: How to store simulation data?

@end deftypefun

@deftypefun {status =} savePhase( @var{mode}, @var{phase}, @var{info} )

Save phase advance to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: phase - numeric (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveBeta ( @var{mode}, @var{beta}, @var{info} )

Save beta to database. Data is permanent across reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: beta - numeric (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveDispersion ( @var{mode}, @var{disp}, @var{info} )

Save dispersion to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: disp - numeric (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveTune ( @var{mode}, @var{tune}, @var{info} )

Save phase advance to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: tune - numeric (double) [nux, nuy].
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {} saveTuneRm ( @var{mode}, @var{rm}, @var{info} )

Save tune response matrix to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: rm - numeric 2-d array (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description (@pxref{Data
Management}: Tune correction matrix).
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveChrom ( @var{mode}, @var{chrom}, @var{info} )

Save chromaticity to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: tune - numeric (double) [chromx, chromy].
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {} saveChromRm ( @var{mode}, @var{rm}, @var{info} )

Save chromaticity response matrix to database. Data is permanent across
reinject/restart machine. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: rm - numeric 2-d array (double).
@item params: info - timestamp, user name, device name(either channel
name or physics name), plane, and description (@pxref{Data
Management}: Chromaticity correction matrix).
@item return: status
@item unit: [TBD].
@end enumerate

@end deftypefun


@deftypefun {chmRm =} getChromRm ( @var{mode} )

Get the stored response matrix(Jacobian) of chromaticity, it is with
respect to sextupoles in dispersive region.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: chmRm - numeric array (double), subset data structure of
(@pxref{Data Management}: Chromaticity correction matrix). 
@item unit: [TBD].
@end enumerate

@deftypefunx {chmRmInfo =} getChromRmInfo ( @var{mode} )

Give full information, such as timestamp, tune, ..., related to
chromaticity response matrix from database.  

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: chmRmInfo - subset data structure of (@pxref{Data
Management}: Chromaticity correction matrix).  
@item unit: [TBD].
@end enumerate

@deftypefunx {nuRm =} getTuneRm ( @var{mode} )

Get tune response matrix from database with respect to (two) quadrupoles.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: nuRm - numeric array (double), subset data structure of
(@pxref{Data Management}: Tune correction matrix). 
@item unit: [TBD].
@end enumerate

@deftypefunx {nuRmInfo =} getTuneRmInfo ( @var{mode} )

Give all details about when and how the tune response matrix was
measured from database. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: nuRmInfo - subset data structure of (@pxref{Data
Management}: Tune correction matrix).  
@item unit: [TBD].
@end enumerate
@end deftypefun

@deftypefun {} convertUnit ( )

Converts between physics and engineering units. (@strong{Needs more information})

Input/output data flow needs to be clarified.

@end deftypefun

@deftypefun {} getDataDirectory ( )
get the directory for storing measurement/analysis data
@end deftypefun


@deftypefun {} getGroundLevel ()

This API is only available in case devices monitoring the level of
ground and/or girder are installed. It returns the reading
values. These values can be used to calibrate the BPM readings.

@deftypefunx {} getChamberOffset ()

This API is only available in case devices monitoring the vacuum
chamber offset are installed. It returns the reading values. These
values can be used to calibrate the BPM readings.
@end deftypefun


@deftypefun {} setCurrentDependency ( )
@deftypefunx {} calibrate ( ) 
@deftypefunx {} getVibrationFrequency ( )
@deftypefunx {} getVibrationSource ( )
@deftypefunx {} Bpm2PbpmReading ( )

@end deftypefun

@end table


@node Orbit Control and Analysis
@section Orbit Control and Analysis

This chapter focus on orbit related functions. 

Do we need to monitorOrbit ? with call back or return ? monitor channel in general ?

@enumerate
@item Obtain static orbit: @code{getOrbit}, @code{getOrbitX}, @code{getOrbitY}, @code{getOrbitDrift}, 
@item Get turn-by-turn orbit: @code{getTbtOrbit}
@item Orbit correct: @code{correctOrbit}
@end enumerate

The APIs should be able to deal with dead BPM automatically (need set
up a convention). 

@node Orbit Control and Analysis API
@section Orbit Control and Analysis API

@table @code
@deftypefun {(orbit, ts, status) =} getOrbit ( @var{sequence}, @var{group}, @var{sync=False})
@tpindex getOrbit

This function returns an array of both horizontal and vertical orbit
at BPMs specified by input @var{sequence} and @var{group}. The
@var{sequence} can be an array of index (1d ? or 2d ?). @var{group} is
a preconfigured string in global property, e.g. ``FOFB'' can be used
for BPMs in fast orbit feedback systems. These orbits are with respect
to golden orbit. 

Use @code{getMembers} to find out locations of the orbit.

Requirement: 
@enumerate
@item @code{getOrbit()}, get orbit at all BPMs;
@item @code{getOrbit("*C01")}, get orbit of BPMs whoes name matches (one "*C01";
@item @code{getOrbit([[1,1], [2,3]])}, get orbit at the 1st BPM in cell 1, 3rd BPM in cell 2; 
@item @code{getOrbit(2,3)} (? 3rd in cell 2 ?) 
@item sychronized to same turn if required. 
@end enumerate

Data structure:
@enumerate
@item params: sequence - pair; sequence pair (@pxref{Terminology for High Level Applications}).
@item params: group - string; group name.
@item params: sync - boolean; synchronized data? False by default
@item return: orbit - numeric (double) array (2-d);

ts - time stamp array;

status - boolean array;

@item unit: [TBD].
@end enumerate


@deftypefunx {(orbit, ts, status) =} getOrbitX ( @var{sequence}, @var{group}, @var{sync=False})
@tpindex getOrbitX

@code{getOrbitX}, returns horizontal orbit. It can be any combination
of single BPM, all in one cell, or whole facility.

Data structure:
@enumerate
@item params: sequence - pair; sequence pair (@pxref{Terminology for High Level Applications}).
@item params: group - string; group name.
@item params: sync - boolean; synchronized data? False by default
@item return: orbit - numeric (double) array (1-d);

ts - time stamp array;

status - boolean array;

@item unit: [TBD].
@end enumerate

@deftypefunx {(orbit, ts, status) =} getOrbitY ( @var{sequence}, @var{group}, @var{sync=False})
@tpindex getOrbitY

@code{getOrbitY}, returns vertical orbit. It can be any combination of
single BPM, all in one cell, or whole facility.

Data structure:
@enumerate
@item params: sequence - pair; sequence pair (@pxref{Terminology for High Level Applications}).
@item params: group - string; group name.
@item params: sync - boolean; synchronized data? False by default
@item return: orbit - numeric (double) array (1-d);

ts - time stamp array;

status - boolean array;

@item unit: [TBD].
@end enumerate

@end deftypefun

@deftypefun {(orbit, ts) =} getTbtOrbit ( @var{sequence},  @var{group}, @var{turn})
@code{getTbtOrbit} returns the TBT(turn by turn) orbit from specified
BPMs, each has @var{turn} turns. 

Data structure:
@enumerate
@item params: sequence - pair; sequence pair (@pxref{Terminology for High Level Applications}).
@item params: group - string; group name, the BPMs in this group have
to have the TBT capability.
@item params: turn - integer; number of how many turn to fetch.
@item return: orbit - numeric (double) array; TBT orbit;

ts - time stamp (array);

@item unit: [TBD].
@end enumerate

@end deftypefun


@strong{The definition of three APIs, @code{getOrbitSnapshot},
@code{getOrbitSnapshotX}, @code{getOrbitSnapshotY}, are not
clear. shot only, no average, what does this stand for? How about
synchronized to same turn? in this API or a new one?}

@deftypefun {orbit =} getOrbitSnapshot ( @var{sequence}, @var{group} )
@code{getOrbitSnapshot*} returns only one shot of the orbit, no
average made (need more discussion with diagnostics). 

@deftypefunx {orbit =} getOrbitSnapshotX ( @var{sequence}, @var{group} )
@code{getOrbitSnapshot*} returns only one shot of the orbit, no
average made (need more discussion with diagnostics).

@deftypefunx {orbit =} getOrbitSnapshotY ( @var{sequence}, @var{group} )
@code{getOrbitSnapshot*} returns only one shot of the orbit, no
average made (need more discussion with diagnostics).

@end deftypefun


@deftypefun {status =} setBpmReference ( @var{group}, @var{ref} )
@code{setBpmReference}, Same as setGoldenOrbit, but only for one
specific BPM. 

@strong{DANGEROUS}: This setting is only valid for one session, not
saved for future Golden orbit(next ramp/injection/run)
                                                                                              
Requirement: May not be able to implemented for other applications using
this information: if I set in one application, is it able to be
reflected in orbit feedback ?  Yes ? no ? or do I really want to?

Data structure:
@enumerate
@item params: group - string; group name.
@item params: ref - numeric (double) array; reference value for each BPM
@item return: status 
@item unit: [TBD].
@end enumerate

@end deftypefun

@deftypefun {orbit =} getGoldenOrbit ( @var{mode} )

@code{getGoldenOrbit} returns the golden orbit for specified operation
mode. This golden orbit is used for online.

Data structure:
@enumerate
@item params: mode - string; mode name. online golden value if empty
@item return: orbit - numeric (double) array (2-d)
@item unit: [TBD].
@end enumerate

@deftypefunx {orbit =} loadGoldenOrbit ( @var{mode}, @var{source="golden_orbit.txt"} )
@code{loadGoldenOrbit} returns the golden orbit for specified
operation mode from a file or database, which is the norminal one. 
We can temporary change golden orbit of online mode, but keep
database untouched, and use @code{loadGoldenOrbit} to reset to the
default one for the current operation mode. 

Data structure:
@enumerate
@item params: mode - string; mode name. Default golden value if empty.
@item params: source - TBD; where to load from, file or database.
@item return: orbit - numeric (double) array (2-d)
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} setGoldenOrbit ( @var{mode}, @var{orbit} )
@code{setGoldenOrbit} sets golden orbit for specified operation mode,
with given @var{orbit}. 

Data structure:
@enumerate
@item params: mode - string; mode name. Current machine mode if empty.
@item params: orbit - numeric array (2-d);
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveGoldenOrbit ( @var{mode}, @var{orbit}, @var{destination="golden_orbit.txt"} )
@code{saveGoldenOrbit} save @var{orbit} to specified @var{destination}.

Data structure:
@enumerate
@item params: mode - string; mode name. Current machine mode if empty.
@item params: orbit - numeric array (2-d);
@item params: destination - TBD; where to store, a file or database.
@item return: status
@item unit: [TBD].
@end enumerate

@c These APIs working on golden orbits, returns the golden orbit for specified
@c operation mode, from a file or database, which is the norminal one. 
@c We can temporary change golden orbit of online mode, but keep
@c database untouched, and use @code{loadGoldenOrbit} to reset to the
@c default one for the current operation mode. Save will take online golden
@c orbit to a file or database.
@end deftypefun

@deftypefun {orbitRm =} getOrbitRm ( @var{mode}, @var{corrector}, @var{bpm} )

Get orbit response matrix from database with given @var{corrector} and
@var{bpm}.

Data structure:
@enumerate
@item params: mode - string; Mode name. Current machine mode by default.
@item params: corrector - string array; list of corrector physics/channel name.
@item params: bpm - string array; list of bpm physics/channel name.
@item return: orbitRm - numeric array (double), subset data structure of
(@pxref{Data Management}: Orbit response matrix). 
@item unit: [TBD].
@end enumerate

@deftypefunx {orbitRmInfo =} getOrbitRmInfo ( @var{mode} )
Give all details about when and how the orbit response matrix was
measured from database with given @var{mode}. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item return: orbitRmInfo - subset data structure of (@pxref{Data
Management}: Orbit response matrix).  
@item unit: [TBD].
@end enumerate

@deftypefunx {orbitRm =} loadOrbitRm ( @var{mode}, @var{source} )

@code{loadOrbitRm} returns the orbit response matrix for specified
operation mode from a file or database. Use @code{loadGoldenOrbit} to
reset to the default one for the current operation mode. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: source - TBD; where to load from.
@item return: orbit response matrix; 
@item unit: [TBD].
@end enumerate


@deftypefunx {status =} setOrbitRm ( @var{mode}, @var{corrector}, @var{bpm} )

@code{loadOrbitRm} returns the orbit response matrix for specified
operation mode from a file or database. Use @code{loadGoldenOrbit} to
reset to the default one for the current operation mode. 

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: corrector - string array; list of corrector physics/channel name.
@item params: bpm - string array; list of bpm physics/channel name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveOrbitRm ( @var{mode}, @var{destination}, @var{info} )

@code{saveOrbitRm} save orbit response matrix to specified @var{destinatoin}.

Data structure:
@enumerate
@item params: mode - string; Mode name.
@item params: destination - TBD; where to save
@item params: info - ;.
@item return: status
@item unit: [TBD].
@end enumerate


@c @code{getOrbitRm} get the orbit response matrix. Requirement: 1. Read
@c the configuration DB to get this RM.  @code{saveOrbitRM}
@c (@code{setOrbitRm}) save the measured Orbit RM. @strong{NOTE}: the column and row
@c are related to the list of correctors and BPMs, they might be changing
@c from time to time, we keep track of the correctors and BPMs using @var{info}

@end deftypefun


@deftypefun {bpm =} getLiveBpm ( )

@code{getLiveBpm} get a list of all live BPM.

Data structure:
@enumerate
@item return: bpm - string array; a list of bpm physics/channel name.
@item unit: [TBD].
@end enumerate

@deftypefunx {bpm =} getDeadBpm ( )

@code{getDeadBpm} get a list of all dead BPM. Those bpm are removed
are not included.

Data structure:
@enumerate
@item return: bpm - string array; a list of bpm physics/channel name.
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} disableBpm ( @var{group} )

@code{disableBpm} disable all bpm(s) belong to certain @var{group}.
A single bpm can be disabled using its physics/channel name.

Data structure:
@enumerate
@item params: group - string; group name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} enableBpm ( @var{group} )

@code{enableBpm} enable all bpm(s) belong to certain @var{group}.
A single bpm can enabled using its physics/channel name.

Data structure:
@enumerate
@item params: group - string; group name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveBpmStatus ( @var{group}, @var{status} )

@code{saveBpmStatus} save status of bpm(s) belong to certain @var{group}.

Data structure:
@enumerate
@item params: group - string; group name.
@item params: status - boolean; bpm boolean status.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {cor =} getLiveCorrector ( )

@code{getLiveCorrector} get a list of all live corrector.

Data structure:
@enumerate
@item return: cor - string array; a list of corrector physics/channel name.
@item unit: [TBD].
@end enumerate

@deftypefunx {cor =} getDeadCorrector ( )

@code{getDeadCorrector} get a list of all dead corrector.

Data structure:
@enumerate
@item return: cor - string array; a list of corrector physics/channel name.
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} disableCorrector ( @var{group} )

@code{disableCorrector} disable corrector(s) belong to certain @var{group}.
A single corrector can be disabled using its physics/channel name.

Data structure:
@enumerate
@item params: group - string; group name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} enableCorrector ( @var{group} )

@code{enableCorrector} enable corrector(s) belong to certain @var{group}.
A single corrector can be enabled using its physics/channel name.

Data structure:
@enumerate
@item params: group - string; group name.
@item return: status
@item unit: [TBD].
@end enumerate

@deftypefunx {status =} saveCorrectorStatus ( @var{group}, @var{status} )

@code{saveCorrectorStatus} save status of corrector(s) belong to certain @var{group}.

Data structure:
@enumerate
@item params: group - string; group name.
@item params: status - boolean; bpm boolean status.
@item return: status
@item unit: [TBD].
@end enumerate

@end deftypefun

@strong{NOTE: Operates on status of BPMs and correctors. enable/disable will not
operate on DB, but @code{save*Status} will mark the dead elements and
take effect across restart.}

@end table

@c -----------------------------------------------------------------------------

@node Diagnostics
@section Diagnostics

@node Diagnostics API
@section Diagnostics API

@strong{This part need more discussion with diagnostics group}

@table @code
@deftypefun {freq =} getRfFrequency ( )
@deftypefunx {h =} getRfHarmonic ( )
@deftypefunx {v =} getRfVoltage ( )
@deftypefunx {phi =} getRfPhase ( )
Retrieve RF information, frequency, harmonic number, voltage, phase ?
@end deftypefun


@deftypefun {min, max =} getPsLimit ( )
Returns lower and upper limits of one power supply (or channel of a magnet ?)
@end deftypefun

@deftypefn {Ext} {major, minor, patch =} version ()
Return version number
@end deftypefn

@deftypefn {Ext} {} whatsup ()
@deftypefnx {Ext} {} howudoing ()
What's up ! How U Doing ! Try this command within 10 seconds you got a
control terminal. Our HLA will tell you what is going on there. The
output is not always the same.
@end deftypefn 


@deftypefun {var =} getChannelVariance ( @var{period} )
@deftypefunx {min,max =} getChannelRange ( @var{channel} )
@deftypefunx {min,max =} getChannelBoundary ( @var{channel} )

@end deftypefun


@deftypefun {current =} getBeamCurrent ( )
@deftypefunx {lifetime =} getBeamLifetime ( )
@deftypefunx {sigmax, sigmay =} getBeamSize ( )
@deftypefunx {} getBeamProfile ( )
@deftypefunx {} getBunchLength ( )
@deftypefunx {} getBunchProfile ( )
Returns beam current, lifetime, size. The profile can be an image (can
we do it in EPICS ?), @code{getBeamProfile} is transverse, and
@code{getBunchProfile} is longitudinal from streak camera type of
instruments.
@end deftypefun

@deftypefun {pres =} getPressure ( @var{loc} )
Vacuum information along the ring (or at specific location ?).
@end deftypefun

@deftypefun {min, max, avg, var =} measSetGetAgreement ( @var{channel}, @var{min}, @var{max}, @var{n} )
Randomly set @math{n} values between @var{min} and @var{max}, check statistics of @math{Rb-Sp}, i.e. the difference of readback and setpoint.
@end deftypefun

@deftypefun {loss =} getLossAt ( @var{loc} )
(Choi, ???) beam loss monitor system
@end deftypefun

@end table


@node Direct Channel Access
@section Direct Channel Access,

In this part, the API talks with real EPICS channels in case we need low
level access. These API can be used for interactive environment to
increase the ability of control. They are also useful in general
plotting/monitoring specified channels when usually the GUI application
was not designed for.

@table @code
@deftypefun {val =} getAm ( @var{am} )
@deftypefunx {val =} getSp ( @var{channel} )
@deftypefunx {val =} setSp ( @var{channel}, @var{value} )
@end deftypefun


@deftypefun {} stepSp ( @var{channel}, @var{low}, @var{high}, @var{n} )
@deftypefunx {} stepSp ( @var{channel}, @var{n} )
change by a small amount. This amount could be different for different
channel/element.  A method “setStepSize” for a channel may be needed.
@end deftypefun

@deftypefun {channels =} getChannels ( @var{element} )
given an element, return all the channel names this element has (confusing with @code{getPv}?)
@end deftypefun

@deftypefun {element =} getChannelOwner ( @var{channel} )
input a channel, return the element name it belongs to. (not a good name ?)
@end deftypefun

@deftypefun {avg, var =} measChannelResponse ( @var{channel}, @var{n} )
Measure how fast set/get response, try @math{n} times, return average and variation in unit of @emph{seconds}
@end deftypefun

@deftypefun {} inChannelLimits ( @var{channel}, @var{setpoint} )
Check whether this setpoint is within the limits.
@end deftypefun

@deftypefun {} getChannelLabel ( @var{channel} )
Get the label for specific channel when do plotting.
@end deftypefun

@deftypefun {} getChannelTolerance ( @var{channel} )
return the tolerance of a channel, i.e. maximum allowed abs(am-sp).
@end deftypefun

@end table


@c -----------------------------------------------------------------------------

@node Extended CAPI
@chapter Extended CAPI

These APIs are not using service directly, but composed of fundamental CAPIs introduced before.

@table @code

@deftypefn {Ext} {} getNearbyBpm ( @var{group} )
return two BPMs bound each element in this group
@end deftypefn

@deftypefn {Ext} {} measBpmLinearity ( @var{bpm} )
MML has this function, test the linearity of BPM readings.
@end deftypefn

@deftypefn {Ext} {} measBeamLifetime ( @var{delay}, @var{npoints}, @var{order} )
Instead of @code{getBeamLifetime} which runs continuously, this routine
get the current and analyze lifetime by fitting a polynomial of certain
order.
@end deftypefn

@deftypefn {Ext} {} measOrbitRm ( ) 
@code{measOrbitRm} set orbit corrector, measure colosed orbit shift.
Requirement: 1. get the list of correctors, in the "orbit correction"
group, from configuration DB; 2. get the list of BPMs, in the "orbit
correction"; 3. set one corrector, get orbit at thoese BPMs;
@end deftypefn

@deftypefn {Ext} {} getTrimQuad ( )
get trim quadrupoles used for tune correction, and their strength ?
Requirement: Read the configuration DB. get the magnet in a certain
"group" or "group name"
@end deftypefn

@deftypefn {Ext} {} measChromaticity ( )
@code{measChromaticity} Measure the chromaticity of current lattice
Requirement: 1. Measure tunes; 2. set(step) RF frequency; 3.  store the
measured chromaticity, overwrite the old one or copy create to a new
one, and set the new one to be default(for this mode) 4. numerical
fitting (polynomial), linear and 2nd order
@end deftypefn

@deftypefn {Ext} {} measChromaticityRm ( )
@code{measChromaticityRm} Measure the RM of chromaticity for
chromaticity correction.  Requirement: 1. measure linear chromaticity;
2. change sextupole settings.
@end deftypefn

@deftypefn {Ext} {} correctChromaticity ( )
@code{correctChromaticity} It is called with desired chromaticity, and
uses chromaticity response matrix to correct the chromaticity and return
the final chromaticity, None if the job is not achieved.
                                                                                              
Requirement: 1. get stored chromaticity RM data. 2. change the sextupole
values (two values for H/V, 30 cells are identical)
@end deftypefn

@deftypefn {Ext} {} setLocalBump ( )
@code{setLocalBump} create a three kicker bump or four kicker local
bump. check the orbit against original state outside of the
bump. Requirement: 1. set 3 or 4 correctors; 2. get whole orbit; 3. get
the location of each corrector and BPMs, so filter the BPMs outside of
the bump. Interplay with feedback system, need flexibility on zero-cross location. need synchronize with other feedforwad table ? (MML has several methods to look at)
@end deftypefn

@deftypefn {Ext} {} getBbaQuad ( )
@end deftypefn

@c @deftypefun {drift =} getOrbitDrift ( @var{sequence}, @var{group}, @var{delay})
@deftypefn {Ext} {min,max =} getOrbitDrift ( @var{sequence}, @var{group}, @var{delay} )
@deftypefnx {Ext} {var =} getOrbitVariance ( @var{sequence}, @var{group}, @var{delay} )
@tpindex getOrbitDrift
This returns the orbit drift after @var{delay} seconds.
@end deftypefn
@c end deftypefun

@deftypefn {Ext} {} measTune ( @var{bpm} )
@deftypefnx {Ext} {} measBeta ( )
@deftypefnx {Ext} {} measPhase ( )
@deftypefnx {Ext} {} measDispersion ( )
@deftypefnx {Ext} {} correctDispersion ( )
@code{measTune} uses turn by turn BPM data to get tune
@end deftypefn


@deftypefn {Ext} {} measTuneRm ( @var{trimx}, @var{trimy} )
@end deftypefn

@deftypefn {Ext} {} getTrimQuad ( )
@end deftypefn

@deftypefn {Ext} {orbit =} correctOrbit ( @var{corrector}, @var{bpm}, @var{iter} )
@deftypefnx {Ext} {orbit =} correctOrbitX ( @var{corrector}, @var{bpm}, @var{iter} )
@deftypefnx {Ext} {orbit =} correctOrbitY ( @var{corrector}, @var{bpm}, @var{iter} )
This function do the orbit correction using default measured orbit response matrix
@end deftypefn

@deftypefn {Ext} {} setCoupling ( @var{couple} )
@end deftypefn

@deftypefn {Ext} {} calcCoupling
@end deftypefn

@deftypefn {Ext} {} getMaxBumpedOrbit ( @var{kickstrength} )
Given certain increase to kicker, what is the maximum orbit shift. This is an estimate of maximum kick strength. The results is tune/beta/mode dependent.
@end deftypefn

@deftypefn {Ext} {} getDeviceList ( @var{sector} )
get device list in certain sector, magnets only, no drift space if using lattice file.
@end deftypefn


@deftypefn {Ext} {} getBpmVariance ( @var{period} )
@code{getBpmVariance} monitor the variance of BPM reading. Same
signature as getOrbit/getOrbitX/getOrbitY, monitor the beam statistics
for a certain time @var{period}. 1sec ? 10 sec ?  From current state or from a given
reference values.
                                                                                              
Requirement: read BPM orbit, can call getOrbit, getOrbitX, getOrbitY
@end deftypefn

@deftypefn {Ext} {} calcTbtOrbitPhase ( )
calculate phase from turn by turn BPM data.
@end deftypefn

@deftypefn {Ext} {der =} measChannelDerivative ( @var{channel_set},  @var{stepsize}, @var{channel_read} )
@deftypefnx {Ext} {der =} measChannelForwardDerivative ( @var{channel_set},  @var{stepsize}, @var{channel_read} )
@deftypefnx {Ext} {der =} measChannelBackwardDerivative ( @var{channel_set},  @var{stepsize}, @var{channel_read} )
Measure the derivatie of @var{channel_read} with respect to @var{channel_set} by midpoint finite difference method. The step size is @var{stepsize}. Forward and backward derivative can also be implemented.
@end deftypefn

@end table


@node Server APIs (SAPI)
@chapter Server APIs (SAPI)

@node Overview
@section overview
In brief, the server APIs do to things, query the lattice settings, and do the settings. 

For example, a HLA wants to do *getOrbit("P\*G2C0?")* (get BPM at girder
2, cell [1,2,3,4,5,6,7,8,9]), the server should be able do two thing:

@enumerate
@item tell what are these elements: (PH1G2C01A, PH2G2C01A, PM1G4C01A,PM1G4C01B, ...)
@item get the orbit of these elements(BPMs), if there is a requirement on the timestamp, apply it. 
@end enumerate

The overview requirementfor SAPI

@itemize 
@item *Lattice Manager*, it manages a lattice as a configure for every HLA, here the manage means: read, set, change these information. 
      @itemize @minus
      @item physics name(unique), logic name(group) of each element.
      @item location (or sequence? we can get this from its location).
      @item channels for setting and reading
      @item limits of each channel
      @item unit convertion infomation (from engineering, e.g. current, to physics value)
      @item risk level (?? warning or not if applications try to set this channel)
      @item ramp speed
      @item step size of setting it
      @item delay for each step when do continues ramping (?? needed or not ??)
      @item used for specified purpose ? (this can be organized as group, quadrupoles used for beam based alignment can be in "BBA" group)
      @item nominal setting (operation lattice)
      @item set point for various set purpose ( for example low alpha lattice, this quadrupole will have different strength. operation lattice is one instance of these set)
      @item query groups it belongs to, how many set of values it can be.
      @item data archiever info, location, frequency, (we can get the history from it)
      @item realtime status? disabled or enabled ? especially for BPM and corrector ?
      @item golden orbit, read/write
      @end itemize
@item I/O, if SAPI has storage integrated, we can use it as a config for I/O
      @itemize @minus
      @item default location for storage
      @end itemize
@item Next block is doing the set/read. After get the information from lattice manager, then we should know how to set the magnet via a server(I here call it a gateway)
      @itemize @minus
      @item call this gateway with an abstract name ? or a channel ? or a list of channels ?
      @item consider the timestamp synchronization ? time out ?
      @item get the value only when the variance of this channel or the other channel is below some threshold ?
      @item get a value in the future, (wait 20ms) ?
      @item get values in a specific time range ? e.g. in the next 10 sec.
      @end itemize
@end itemize

@node Name Convention for Server Record
@section Name Convention for Server Record

The server is designed against EPICS-4. It provides a capability to
create a a record dnamically. User should follow the NSLS-II name
convention when creating any record.{ @cite{National Synchrotron Light
Source II - Nomenclature Standard}, @cite{National Synchrotron Light
Source II - Accelerator Systems Requirements Document, Storage Ring
Physics Nomenclature Standard}, @pxref{Reference}}. 

@node Data storage API
@section Data storage API

The strategy for data storage is based on the server adopted for
NSLS-II project. For example, the data archiving system, and or
machine status snapshot so-call logscore system. The API described
here is for a data server to retrieve from data archiving system for
example to provide them to client in a pre-defined structure.

@node Data archiving API
@subsection Data archiving API
Coming soon.

@node Logscore API
@subsection Logscore API
Coming soon.



@node Reference
@unnumbered Reference

@itemize @asis
@enumerate
@item J. Bengtsson, B. Dalesio, T. Shaftan, T. Tanabe, @cite{NSLS-II:
Model Based Control - A Use Case Approach}, Tech-note 51, Oct 2008 

@item F. Willeke, @cite{Assumptions on NSLS-II Accelerator Commissioning}, November 22, 2009

@item F. Willeke, @cite{The Path to Accelerator Commissioning}, talk
on ASD Project Meeting, Jan 2010

@item S. Krinsky, @cite{NSLS-II Storage Ring Commissioning}, NSLS-II ASD Retreat, May 13, 2010.

@item @cite{National Synchrotron Light Source II - Nomenclature Standard},
LT-ENG-RSI-STD-002, Jan 21, 2009, Rev 2

@item @cite{National Synchrotron Light Source II - Accelerator Systems
Requirements Document, Storage Ring Physics Nomenclature Standard},
RSI Document 1.3.4-001, Feb 17, 2008, Rev 1

@item G.Shen, Y. Hu, B. Dalesio, @cite{Circular Buffer Diagnostic}

@item @cite{Python}, @uref{http://www.python.org/}

@item @cite{iPython}, @uref{http://ipython.scipy.org/moin/}

@item @cite{Matplotlib}, @uref{http://matplotlib.sourceforge.net/}

@item @cite{SciPy}, @uref{http://numpy.scipy.org/}

@end enumerate
@end itemize

@iftex
@normalbottom
@end iftex

@node Index
@unnumbered Index

@printindex cp

@node Function Index, Variable Index
@unnumbered Function Index

@printindex fn



@node Notes
@unnumbered Note

@enumerate
@item How long to fix (or by pass) an unpredicted situation(or more worse, a bug?) in control room, in a two hours shift ?
@item Server side log ?
@item How to keep the server(manager) most updated
@end enumerate

@node Coding Style
@heading Coding Style

@enumerate
@item Use @code{doxygen} for @code{C/C++} ?
@item write @code{__doc__} in Python ?
@item Use @code{sphinx} for Python ?
@item 4 spaces per indentation level.
@item never mix tabs and spaces. Use space to replace tab
@item limit all lines to a maximum of 79 characters.
@item document well and in detail.
@end enumerate

@node Summary of Meetings
@heading Summary of Meetings
@c unnumbered Summary of Meetings

@enumerate
@item @strong{2010/04/23, Bob, Choi, Don, Guobao and Lingyun}
      @itemize @minus
      @item Guobao showed implementations of two server, a use case of global
     orbit is presented. Exposed some details to us, and helpful to
     implement a CAPI, and a guide for defining the SAPI.
     @item Should we have a server side log ? like Apache log in linux ?
   @item We should be able to define "a set of magnets" and save it, leave
     comments and username. So in the future, we can recall this set, and monitor the data
   @item We will have a more detailed description of CAPI, for Guobao and Don
     to define the SAPI.
   @item We will have an example of "creating local orbit bump" based on this
     architecture, and show them in AP group, and have more discussions.
   @item On the server side, we agreed to have more discussions on what kind of functions can be provided to CAPI, and how to use them. Take the "creating local orbit bump" as an example to move toward the CAPI requirement. After several discussions, two groups from two sides can merge together with a complete set of CAPI/SAPI.
@end itemize
@end enumerate

@node Tools/Coding/Documentation
@heading Tools/Coding/Documentation

@itemize
@item C/C++ and Python would be the main language for HLAs development and data process.
@item Python_ + iPython_ + matplotlib_ + numpy_ are preferred for
   *Interactive Environment*. For people who prefer MATLAB, we also provide MATLAB Middle Layer Toolkit (MMLT) by Greg Portman at Lawrence Berkeley National Laboratory as an option.
@item The HLAs can be written in Python, in this case we prefer PyQt as GUI
   library. This makes the sharing of API between interactive environment
   and HLAs easy. However, we can also use C bindings of EPICS, then
   Qt/C++ as GUI library. For applications use only low level API
   (operates on channels directly) this can also be a recommended choice.
 @item Other monitoring applications can be constructed from MEDM or CSS.
 @item A central repository will be set up, and code review (or other form of
   discussion the code we have written) will also be arranged.
 @item A running virtual accelerator is already running, and use for testing
   the HLAs.
@end itemize

@c @node Appendix
@c chapter Appendix

@node Terminology Definition for Control System
@heading Terminology Definition for Control System

@itemize
@enumerate
@item EPICS
@cindex EPICS
@item Channel
@cindex Channel
@item Record
@cindex Record
@item PV (Process Variable)
@cindex PV
@cindex Process Variable
@item CA (Channel Access)
@cindex CA
@cindex Channel Access
@end enumerate
@end itemize

@node Revision History
@heading Revision History

@itemize @bullet
@item 2010-10-14, ASAC review
@item 2010-06-24, discuss with group leaders and ASD head.
@item 2010-06-14, Guobao Shen, rev 1
@item 2010-06-08, Lingyun Yang, init
@end itemize


@bye
